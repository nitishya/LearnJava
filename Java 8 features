1) Lambda  Expresions 
2) Functional Interfaces 
3) Default methods in Interfaces 
4) Static methods in Interfaces
5) Predicate }
6) Function  }---- predefined function in functional  interfaces 
7) Consumer  }
8) Method references and Constructor refernces By doublel colon (::) operator 
9) Stream Api 
10) Date and Time APi (Joda API )



---------------------------------------------------------------------------------------------------------------
why java 8 - to simplify the way of writing code. more clean code , more maintainable code 
           -> To utilize functional programmming 
           -> To enable parallel programming 



----------------------------------------------------------------------------------------------------------------

what is Lambda expression - lambda expression is annonymous function.

Lambda Expressions -> anonymous function ,nameless function
                   -> points to remember - not having name 
                                         - not having modifiers 
                                         - not having return type

   public❌ void❌ m1❌(){                      |
     System.out.println("Hello");                |   --   ()->{ System.out.println("Hello");}
   }                                             |

it is very easy ...if you know java method.

	public❌ void❌ add❌(int a,int b) {             |
		System.out.println(a+b);                        |-   (int a, int b) ->{System.out.println(a+b);};
	}                                                  |    based on situation compiler can guess the output type k/a Type Inference
                                                      |    (a,b)->System.out.println(a+b);

   public❌ int❌ getLength❌(String s){             |
      return s.length();                              |    ---> (String s) -> {return s.length();}
   }                                                  |         (s)->return s.length()  
                                                      |         (s)->s.length()
                                                      |          s->s.length()


why Lambda expression -> To enable functional programming in java 
                      -> Write more readable , maintainable and consize code 
                      ->To use APIs very easily and effectively.
                      ->To enable parallel processing.


public void m(){                |
 sys("Hello");                  |    ->  ()-> {sys("hello")} ;   => () -> sys("hello");
}                               |        if only one statement is there we can skip curly braces.
             

Characterstics/properties of lambda expression-
1.A lambda expression can  take any number of parameters.
2.If multiple parameters present then these parameters should be seperated with ,
3.If only one parameter available then parameter are optional.
4.Usually we specify the type of parameter if compiler expect the type based on content, then we can remove type [k/a Type Inference]
5.Similar to method body, Lambda expression body can contain any number of any muber of statements.If multiple statements are there then we should enclose with curly braces.
6.If body contains only one statement then curly braces are optional.



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Functional Interface -> To invoke the lambda function we require functional Interface.
                     -> If the interface contain only one abstract method then that interface is called Fuctional Interface.

example - Runnable   -> contains only one method run().
        - Callable   -> conatins only one method call().
        - ActionListener -> contains only  one method actionPerformed().
        - Comparable  -> contains only one method compareTo() 

Rule if applicable only for abstract methods. How Many abstract methods - only one.
How many default methods can we take - any number of default methods.
How many static methods can we take - any number of static methods.


@FunctionalInterface ->To indicate the compiler that this will be functional interface by mistake if two abstract method creates than it will show Compile Time Error.

        @FunctionalInterface
	interface Interf{
		public void m1();
		
		default void m2() {
			
		}
		
		public static void m3() {
			
		}
		
	}
l












----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Streams in java 

Java 8 streams and Java I/O Streams are different from each other.

Java I/O Streams >> Working with files i.e. Reading and Writing 
Java 8 Streams >> Processing and filtering data over different data Sources.


Collections and Streams purpose also different from each others.

Collections  >> Storing the data 
Streams      >> Processing and Filtering data over different data sources.



Definition of Streams ->
Stream represent sequence of objects derived from a source (Arrays, COllections, IO resources ) over which aggregate operations can be performed .
Technically Stream is Typed Interface which means that stream can be defined for any kind of objects , Stream of characters , Stream of employees/customer/cities.

Characterstics of Streams ->

Element Sequence -> Stream provide a set of elements of particular type in seqential manner.The Stream gets an element on demand and never store an item.
Source -> Stream can take the data from different sources such as Collection , Arrays , I/O Resources etc.
Aggregate Operations -> Streams support aggregate operations such as forEach, filter , Map , Sorted and so on .
Automated Iterations -> Stream operations carry out iterations internally over the sources of elements as opposed to collections where explicit iteration is required.


How to get stream object -> just by calling the stream method on collection object.


Different ways to create Stream Object 

1) Creating empty Stream object which allowed to string values only 
   Stream <String> names = Stream.empty();

2) Creating stream object from collection Object
   Collection<String> names = Arrays.asList("Mahesh","Suresh","Ramesh");
   Stream nameStream = names.stream();

3) Creating stream object from Array
   String[] arr = new String[]{"a","b","c"};
   Stream<String> streamOfArrayFull = Arrays.stream(arr);

4) We can create Stream object by using builder method 
   when builder is used , the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the 
   Stream<Object>:
   Stream<String> nameStream = Stream.<String>builder()
                               .add("a")
                               .add("b")
                               .add("c")
                               .build()


In a java program we can perform 2 Kind of operation 

<a href="the-url-you-want-to-go-when-image-is-clicked.com" />
<img src="https://javagoal.com/wp-content/uploads/2020/01/22-1.jpg" />
![alt text](https://javagoal.com/wp-content/uploads/2020/01/22-1.jpg)









